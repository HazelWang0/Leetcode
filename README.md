# UPDATE
- Jan.10   [删除链表的倒数第 N 个结点](19.删除链表的倒数第-n-个结点.py)    
    > **虚拟头+快慢指针**:    如果慢指针比快指针多慢，就需要再构造一个dummy头增加位置，防止出现快指针出错的情况  
- Jan.10    [876.链表的中间结点](876.链表的中间结点.py)  
    > **快慢指针**:     如果链表长度是偶数，该解法返回的是靠后的节点  
    *理由*：常规链表的跳出循环的条件是当前节点是null，本题检查当前节点和下一节点是否为null，如果从head开始判断，就是先偶后奇的顺序。
- Jan.11    [76.最小覆盖子串](76.最小覆盖子串.cpp)
    > **滑动窗口**：    模板
- Jan.15    [567.字符串的排列](76.最小覆盖子串.cpp)
    > **滑动窗口**：    需要考虑左窗口开始滑动的条件是什么，true的条件判断放在哪里  
    > 本题 [left, right) 维护的是一个定长的窗口，所以 while 可以改成 if  
    > **需要review**
- Jan. 19   [5.最长回文子串](5.最长回文子串.java)
    > **中心扩散+双指针**
- Jan. 19   [509.斐波那契数](509.斐波那契数.py)
    > **动态规划+自顶向下递归**:  重叠子问题,用额外的memo数组来存储已经计算过的值，否则将超时  
    > 注意python的写法  

# NOTES
- [**二叉堆**](https://labuladong.github.io/algo/di-yi-zhan-da78c/shou-ba-sh-daeca/er-cha-dui-1a386/)  
    二叉堆是数组形式的完全二叉树，主要操作是上浮swim和下沉sink  
  - **优先级队列(PriorityQueue)**  
      是基于二叉堆实现的，父节点始终大于子节点。它的上浮比较简单，直接比较当前节点和父节点大小；下沉则要将当前值和子节点中最大值进行比较

- [**滑动窗口**](https://labuladong.github.io/algo/di-yi-zhan-da78c/shou-ba-sh-48c1d/wo-xie-le--f7a92/)  
   left 指针在后，right 指针在前，两个指针中间的部分就是「窗口」，算法通过扩大和缩小「窗口」来解决某些问题。**主要考虑三个问题：**   
   - 什么时候应该扩大窗口？  
   - 什么时候应该缩小窗口？  
   - 什么时候应该更新答案？  
- [**二叉树**](https://labuladong.github.io/algo/di-ling-zh-bfe1b/dong-ge-da-334dd/)  
    二叉树题目的递归解法可以分两类思路，第一类是**遍历**一遍二叉树得出答案，第二类是通过**分解**问题计算出答案，这两类思路分别对应着 **回溯算法核心框架** 和 **动态规划核心框架**。  
    **遍历和分解的区别**：两者都需要进行二叉树的遍历，但分解是把大问题拆分为小问题，每个小问题本身就可以返回答案；而遍历则没有这么直接，需要另外维护一个**外部变量**来得到最终答案。   
    每道题都要明白二叉树的每一个节点需要做什么，需要在什么时候（前中后序）做  
    - 前序位置的代码执行是自顶向下的，而后序位置的代码执行是自底向上；前序位置的代码只能从函数参数中获取父节点传递来的数据，而后序位置的代码不仅可以获取参数数据，还可以获取到子树通过函数返回值传递回来的数据    
    - 快速排序就是个二叉树的前序遍历，归并排序就是个二叉树的后序遍历 
    - 中序遍历是二叉树特有的，多叉树中不存在   
    - 一旦题目和子树有关，那大概率要给函数设置合理的定义和返回值，在后序位置写代码了  

- [**动态规划**](https://labuladong.github.io/algo/di-ling-zh-bfe1b/dong-tai-g-1e688/)  
    核心思想是穷举求最值，列出正确的「状态转移方程」，才能正确地穷举。重叠子问题、最优子结构、状态转移方程是动态规划三要素，需要判断算法问题是否具备「最优子结构」，是否能够通过子问题的最值得到原问题的最值。
    - *重叠子问题*：使用备忘录来剪枝，优化穷举过程，避免不必要的计算  

