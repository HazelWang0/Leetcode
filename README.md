# UPDATE
- Jan.10   [删除链表的倒数第 N 个结点](19.删除链表的倒数第-n-个结点.py)     
    > **虚拟头+快慢指针**:    如果慢指针比快指针多慢，就需要再构造一个dummy头增加位置，防止出现快指针出错的情况  
- Jan.10    [876.链表的中间结点](876.链表的中间结点.py)    
    > **快慢指针**:     如果链表长度是偶数，该解法返回的是靠后的节点   
    *理由*：常规链表的跳出循环的条件是当前节点是null，本题检查当前节点和下一节点是否为null，如果从head开始判断，就是先偶后奇的顺序。  
- Jan.11    [76.最小覆盖子串](76.最小覆盖子串.cpp)  
    > **滑动窗口**：    模板  
- Jan.15    [567.字符串的排列](76.最小覆盖子串.cpp)  
    > **滑动窗口**：    需要考虑左窗口开始滑动的条件是什么，true的条件判断放在哪里  
    > 本题 [left, right) 维护的是一个定长的窗口，所以 while 可以改成 if  
    > **bug review**  
- Jan. 19   [5.最长回文子串](5.最长回文子串.java)  
    > **中心扩散+双指针**  
- Jan. 19   [509.斐波那契数](509.斐波那契数.py)   
    > **动态规划+自顶向下递归+重叠子问题**:  重叠子问题,用额外的memo数组来存储已经计算过的值，否则将超时  
    > 注意python的写法  
- Feb. 5   [322.零钱兑换](322.零钱兑换.py)   
    > **动态规划+自顶向下递归+重叠子问题**:  同上，增加判断条件    
- Feb. 5   [46.全排列](46.全排列.py)  
    > **回溯问题**：    模板  
    > **bug review**  
- Feb. 5   [51.n-皇后](51.n-皇后.py)   
    > **回溯问题+只一种解法的情况**：    同上  
    > **bug review**  

- Jun. 26  [所有可能的路径](797.%E6%89%80%E6%9C%89%E5%8F%AF%E8%83%BD%E7%9A%84%E8%B7%AF%E5%BE%84.py)
  - > 模板   

# NOTES
- [**二叉堆**](https://labuladong.github.io/algo/di-yi-zhan-da78c/shou-ba-sh-daeca/er-cha-dui-1a386/)  
    二叉堆是数组形式的完全二叉树，主要操作是上浮swim和下沉sink  
  - **优先级队列(PriorityQueue)**  
      是基于二叉堆实现的，父节点始终大于子节点。它的上浮比较简单，直接比较当前节点和父节点大小；下沉则要将当前值和子节点中最大值进行比较

- [**滑动窗口**](https://labuladong.github.io/algo/di-yi-zhan-da78c/shou-ba-sh-48c1d/wo-xie-le--f7a92/)  
   left 指针在后，right 指针在前，两个指针中间的部分就是「窗口」，算法通过扩大和缩小「窗口」来解决某些问题。**主要考虑三个问题：**   
   - 什么时候应该扩大窗口？  
   - 什么时候应该缩小窗口？  
   - 什么时候应该更新答案？  
- [**二叉树**](https://labuladong.github.io/algo/di-ling-zh-bfe1b/dong-ge-da-334dd/)  
    二叉树题目的递归解法可以分两类思路，第一类是**遍历**一遍二叉树得出答案，第二类是通过**分解**问题计算出答案，这两类思路分别对应着 **回溯算法核心框架** 和 **动态规划核心框架**。  
    **遍历和分解的区别**：两者都需要进行二叉树的遍历，但分解是把大问题拆分为小问题，每个小问题本身就可以返回答案；而遍历则没有这么直接，需要另外维护一个**外部变量**来得到最终答案。   
    每道题都要明白二叉树的每一个节点需要做什么，需要在什么时候（前中后序）做  
    - 前序位置的代码执行是自顶向下的，而后序位置的代码执行是自底向上；前序位置的代码只能从函数参数中获取父节点传递来的数据，而后序位置的代码不仅可以获取参数数据，还可以获取到子树通过函数返回值传递回来的数据    
    - 快速排序就是个二叉树的前序遍历，归并排序就是个二叉树的后序遍历 
    - 中序遍历是二叉树特有的，多叉树中不存在   
    - 一旦题目和子树有关，那大概率要给函数设置合理的定义和返回值，在后序位置写代码了  

- [**动态规划**](https://labuladong.github.io/algo/di-ling-zh-bfe1b/dong-tai-g-1e688/)      
    核心思想是穷举求最值，列出正确的「状态转移方程」，才能正确地穷举。重叠子问题、最优子结构、状态转移方程是动态规划三要素，需要判断算法问题是否具备「最优子结构」，是否能够通过子问题的最值得到原问题的最值。
    - *重叠子问题*：使用备忘录来剪枝，优化穷举过程，避免不必要的计算  

- [**回溯算法**](https://labuladong.github.io/algo/di-ling-zh-bfe1b/hui-su-sua-c26da/)  
    和动态规划类似，但不直接返回结果，用额外的数组来维护返回值   
    **回溯算法和 DFS 算法的区别所在：回溯算法关注的不是节点，而是树枝**  
    核心就是 for 循环里面的递归，在递归调用之前「做选择」，在递归调用之后「撤销选择」  
    回溯算法的一个特点，不像动态规划存在重叠子问题可以优化，回溯算法就是纯暴力穷举，复杂度一般都很高   

- [**BFS**](https://labuladong.github.io/algo/di-ling-zh-bfe1b/bfs-suan-f-463fd/)  
    传统的 BFS 框架就是从起点开始向四周扩散，遇到终点时停止；而双向 BFS 则是从起点和终点同时开始扩散，当两边有交集的时候停止。但双向BFS必须知道终点在哪里   
    不再使用队列，而是使用 HashSet 方便快速判断两个集合(从头开始，从终点开始)是否有交集。另外的一个技巧点就是 while 循环的最后交换 q1 和 q2 的内容，所以只要默认扩散 q1 就相当于轮流扩散 q1 和 q2  
    最后一个技巧：按照 BFS 的逻辑，队列（集合）中的元素越多，扩散之后新的队列（集合）中的元素就越多；在双向 BFS 算法中，如果每次都选择一个较小的集合进行扩散，那么占用的空间增长速度就会慢一些，效率就会高一些  
    
          


- [**图**](https://labuladong.github.io/algo/di-yi-zhan-da78c/shou-ba-sh-03a72/tu-lun-ji--d55b2/)  
    如果图包含环，遍历框架就要一个 visited 数组进行辅助, visited 数组就是防止递归重复遍历同一个节点进入死循环的  
    类比贪吃蛇游戏，visited 记录蛇经过过的格子，而 onPath 仅仅记录蛇身。在图的遍历过程中，onPath 用于判断是否成环, 处理路径相关的问题，如 拓扑排序, onPath 变量是有必要的.  
